using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;


[assembly: InternalsVisibleToAttribute("Operating_System_User_Space")]
//ay es atribut@ kirarelov menq Operating_System_User_Space assemblyn  sarqum enq mer es assembly in @nker
// u Operating_System_User_Space assembly um tesaneli en linelu mer es essembly i internal classner@
//mer es zborkayi bolor classneri tesaneliutyan tiruyt@ nshvac chi vorovhetev C# um defaylt Internal a
//thanks for reading :D ,bye

namespace Operating_System_Kernel

{
    class File_System
    {
        byte Counter=0;
        Super_Block superblok = new Super_Block();
        Array_Of_I_Nodes_Address I_Node_Table = new Array_Of_I_Nodes_Address();
        Information_Of_Free_Blocks bitavaya_karta = new Information_Of_Free_Blocks();


        

// Create (Создать).
//Создает файл без данных. Цель вызова состоит в объявлении
//о появлении нового файла и установке ряда атрибутов.
        public void create(byte mode)
        {
            I_Node i_node = new I_Node(mode);
           // hima petqa tanenq es i_node i parunakutyun@ hard diski vra grenq u et graci arajin biti hascen grenq
            //I_Node_Table.array_Of_I_Nodes[counter] um
                
            
        }

//Delete (Удалить). Когда файл больше не нужен, его нужно удалить, чтобы освобо-
//дить дисковое пространство. Именно для этого и предназначен этот системный
//вызов.

//Open (Открыть). Перед использованием файла процесс должен его открыть. Цель
//системного вызова open — дать возможность системе извлечь и поместить в опера-
//тивную память атрибуты и перечень адресов на диске, чтобы ускорить доступ к ним
//при последующих вызовах.

//Close (Закрыть). После завершения всех обращений к файлу потребность в его
//атрибутах и адресах на диске уже отпадает, поэтому файл должен быть закрыт,
//чтобы освободить место во внутренней таблице. Многие системы устанавливают
//максимальное количество открытых процессами файлов, определяя смысл суще-
//ствования этого вызова. Информация на диск пишется блоками, и закрытие файла
//вынуждает к записи последнего блока файла, даже если этот блок и не заполнен.

//Read (Произвести чтение). Считывание данных из файла. Как правило, байты по-
//ступают с текущей позиции. Вызывающий процесс должен указать объем необхо-
//димых данных и предоставить буфер для их размещения.

//Write (Произвести запись). Запись данных в файл, как правило, с текущей позиции.
//Если эта позиция находится в конце файла, то его размер увеличивается. Если теку-
//щая позиция находится где-то в середине файла, то новые данные пишутся поверх
//существующих, которые утрачиваются навсегда.

//Append (Добавить). Этот вызов является усеченной формой системного вызова
//write. Он может лишь добавить данные в конец файла. Как правило, у систем, предо-
//ставляющих минимальный набор системных вызовов, вызов append отсутствует, но
//многие системы предоставляют множество способов получения того же результата,
//и иногда в этих системах присутствует вызов append.

//Seek (Найти). При работе с файлами произвольного доступа нужен способ указания
//места, с которого берутся данные. Одним из общепринятых подходов является при-
//менение системного вызова seek, который перемещает указатель файла к определен-
//ной позиции в файле. После завершения этого вызова данные могут считываться
//или записываться с этой позиции.

//Get attributes (Получить атрибуты). Процессу для работы зачастую необходимо
//считать атрибуты файла. К примеру, имеющаяся в UNIX программа make обычно
//используется для управления проектами разработки программного обеспечения,
//состоящими из множества сходных файлов. При вызове программа make проверяет
//время внесения последних изменений всех исходных и объектных файлов и для
//обновления проекта обходится компиляцией лишь минимально необходимого ко-
//личества файлов. Для этого ей необходимо просмотреть атрибуты файлов, а именно
//время внесения последних изменений.

// Set attributes (Установить атрибуты). Значения некоторых атрибутов могут уста-
//навливаться пользователем и изменяться после того, как файл был создан. Такую
//возможность дает именно этот системный вызов. Характерным примером может
//послужить информация о режиме защиты. Под эту же категорию подпадает боль-
//шинство флагов.

//Rename (Переименовать). Нередко пользователю требуется изменить имя существу-
//ющего файла. Этот системный вызов помогает решить эту задачу. Необходимость
//в нем возникает не всегда, поскольку файл может быть просто скопирован в новый
//файл с новым именем, а старый файл затем может быть удален.

        ///////////////////////////////////////////////////////////////////////////sksuma kataloog@

//Create (Создать каталог). Каталог создается пустым, за исключением точки и двой-
//ной точки, которые система помещает в него автоматически (или в некоторых
//случаях при помощи программы mkdir).

//Delete (Удалить каталог). Удалить можно только пустой каталог. Каталог, содержа-
//щий только точку и двойную точку, рассматривается как пустой, поскольку они не
//могут быть удалены.

//Opendir (Открыть каталог). Каталоги могут быть прочитаны. К примеру, для вы-
//вода имен всех файлов, содержащихся в каталоге, программа ls открывает каталог
//для чтения имен всех содержащихся в нем файлов. Перед тем как каталог может
//быть прочитан, он должен быть открыт по аналогии с открытием и чтением файла.

//Closedir (Закрыть каталог). Когда каталог прочитан, он должен быть закрыт, чтобы
//освободить пространство во внутренних таблицах системы.

//Readdir (Прочитать каталог). Этот вызов возвращает следующую запись из от-
//крытого каталога. Раньше каталоги можно было читать с помощью обычного
//системного вызова read, но недостаток такого подхода заключался в том, что про-
//граммист вынужден был работать с внутренней структурой каталогов, о которой
//он должен был знать заранее. В отличие от этого, readdir всегда возвращает одну
//запись в стандартном формате независимо от того, какая из возможных структур
//каталогов используется.

//Rename (Переименовать каталог). Во многих отношениях каталоги подобны файлам
//и могут быть переименованы точно так же, как и файлы.

//Link (Привязать). Привязка представляет собой технологию, позволяющую файлу
//появляться более чем в одном каталоге. В этом системном вызове указываются
//существующий файл и новое имя файла в некотором существующем каталоге
//и создается привязка существующего файла к указанному каталогу с указанным
//новым именем. Таким образом, один и тот же файл может появиться в нескольких
//каталогах, возможно, под разными именами. Подобная привязка, увеличивающая
//показания файлового счетчика i-узла (предназначенного для отслеживания коли-
//чества записей каталогов, в которых фигурирует файл), иногда называется жесткой
//связью, или жесткой ссылкой (hard link).

//Unlink (Отвязать). Удалить запись каталога. Если отвязываемый файл присутству-
//ет только в одном каталоге (что чаще всего и бывает), то этот вызов удалит его из
//файловой системы. Если он фигурирует в нескольких каталогах, то он будет уда-
//лен из каталога, который указан в имени файла. Все остальные записи останутся.
//Фактически системным вызовом для удаления файлов в UNIX (как ранее уже было
//рассмотрено) является unlink.
    }
}
